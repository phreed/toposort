/*
* @author Samuel Neff (https://github.com/samuelneff)
*
* based almost entirely on gist from
*
* @author SHIN Suzuki (shinout310@gmail.com)
*
 * https://gist.github.com/shinout/1232505
*/
"use strict";
/// <reference types="node" />
/// <reference types="core-js" />
(function (Mark) {
    Mark[Mark["UNMARKED"] = 0] = "UNMARKED";
    Mark[Mark["TEMPORARY"] = 1] = "TEMPORARY";
    Mark[Mark["PERMANENT"] = 2] = "PERMANENT";
})(exports.Mark || (exports.Mark = {}));
var Mark = exports.Mark;
var AdjacencyNode = (function () {
    function AdjacencyNode(node) {
        this.mark = Mark.UNMARKED;
        this.node = [node];
        this.dep = [];
    }
    AdjacencyNode.prototype.append = function (node) {
        if (typeof node === "undefined") {
            return;
        }
        this.node.push(node);
    };
    return AdjacencyNode;
}());
exports.AdjacencyNode = AdjacencyNode;
/**
 * Build a AdjacencyList of the form:
 * Given:
 *   [[2,1], [3,2]]
 * Result:
 *  const an1 = { "node": [1], "mark": 0, "dep": [] };
 *  const an2 = { "node": [2, 1], "mark": 0, "dep": [an1] };
 *  const an3 = { "node": [3, 2], "mark": 0, "dep": [an2] };
 * [ an1, an2, an3 ]
 *
 * The an1 adjacency node is added.
 */
function ConstructAdjacencyList(list, methods) {
    // Builds a map based on a key generated by 'keyFn'.
    var lookup = new Map();
    list.forEach(function (node) {
        var key = methods.keyFn(node);
        if (lookup.has(key)) {
            lookup.get(key).append(node);
        }
        else {
            lookup.set(key, new AdjacencyNode(node));
        }
    });
    // Populate the dependancy array for each adjacency node.
    lookup.forEach(function (value) {
        for (var _i = 0, _a = value.node; _i < _a.length; _i++) {
            var depnode = _a[_i];
            for (var _b = 0, _c = methods.depsFn(depnode); _b < _c.length; _b++) {
                var depkey = _c[_b];
                var deprec = lookup.get(depkey);
                if (typeof deprec === "undefined") {
                    deprec = new AdjacencyNode(methods.nullNode(depkey));
                    lookup.set(depkey, deprec);
                }
                // the dependency portion
                value.dep.push(deprec);
            }
        }
    });
    var result = [];
    lookup.forEach(function (value) {
        if (typeof value === "undefined") {
            return;
        }
        result.push(value);
    });
    return result;
}
exports.ConstructAdjacencyList = ConstructAdjacencyList;
/**
 * General Topological Sort
 *
 * https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search
 *
 * while there are UNMARKED nodes:
 *   select an UNMARKED node N
 *   VISIT N
 *
 * VISIT N
 *   if N has a TEMPORARY mark then you have a cycle
 *   if N is UNMARKED:
 *      TEMPORARY mark N
 *      for each dependency M of N:
 *         VISIT M
 *      PERMANENT mark N
 *      push N to L
 *
 * @param nodes : list of nodes
 *        The precise sort is, of course, not guaranteed.
 * @returns Array : topological sorted list of T's
 **/
function Toposort(nodes, methods) {
    var al = ConstructAdjacencyList(nodes, methods);
    var result = [];
    var VISIT = function (na) {
        if (na.mark === Mark.TEMPORARY) {
            na.node.forEach(function (node) { methods.cycleFn(node); });
            return;
        }
        if (na.mark === Mark.PERMANENT) {
            return;
        }
        na.mark = Mark.TEMPORARY;
        if (typeof na.dep !== "undefined") {
            na.dep.forEach(function (ma) { VISIT(ma); });
        }
        na.mark = Mark.PERMANENT;
        na.node.forEach(function (node) { result.unshift(node); });
    };
    al.forEach(function (na) { VISIT(na); });
    return result;
}
exports.Toposort = Toposort;
//# sourceMappingURL=toposort.js.map