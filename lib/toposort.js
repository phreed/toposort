/*
* @author Fred Eisele (https://github.com/phreed)
*
*/
"use strict";
(function (Mark) {
    Mark[Mark["UNMARKED"] = 0] = "UNMARKED";
    Mark[Mark["TEMPORARY"] = 1] = "TEMPORARY";
    Mark[Mark["PERMANENT"] = 2] = "PERMANENT";
})(exports.Mark || (exports.Mark = {}));
var Mark = exports.Mark;
var NodeMethods = (function () {
    function NodeMethods() {
    }
    /**
     * Constuct a node given only the key.
     * Something like the inverse of keyFn.
     */
    NodeMethods.prototype.nullNode = function (key) {
        return null;
    };
    /**
     * The keyFn returns a key when passed a node.
     * an example for buildin a key given a number.
     * If the node should be dropped from the adjacency
     * list then undefined in returned.
     */
    NodeMethods.prototype.keyFn = function (node) {
        return null;
    };
    /**
     * The depsFn returns the keys for a set of dependencies for a node.
     * An example for indexing a list of numbers
     * paired with an array of depencencies.
     */
    NodeMethods.prototype.depsFn = function (node) {
        return [];
    };
    /**
     * The depsFn returns the keys for a set of dependencies for a node.
     */
    NodeMethods.prototype.predsFn = function (node) {
        return [];
    };
    /**
     * This function is called when a cyclic dependency is located.
     * Generally you will want to save off the
     * offending node for special processing.
     */
    NodeMethods.prototype.cycleFn = function (node) { };
    return NodeMethods;
}());
exports.NodeMethods = NodeMethods;
var AdjacencyNode = (function () {
    function AdjacencyNode(node) {
        this.mark = Mark.UNMARKED;
        this.node = [node];
        this.dep = [];
    }
    AdjacencyNode.prototype.append = function (node) {
        if (typeof node === "undefined") {
            return;
        }
        this.node.push(node);
    };
    return AdjacencyNode;
}());
exports.AdjacencyNode = AdjacencyNode;
/**
 * Build a AdjacencyList of the form:
 * Given:
 *   [[2,1], [3,2]]
 * Result:
 *  const an1 = { "node": [1], "mark": 0, "dep": [] };
 *  const an2 = { "node": [2, 1], "mark": 0, "dep": [an1] };
 *  const an3 = { "node": [3, 2], "mark": 0, "dep": [an2] };
 * [ an1, an2, an3 ]
 *
 * The an1 adjacency node is added.
 */
function ConstructAdjacencyList(list, methods) {
    // Builds a map based on a key generated by 'keyFn'.
    var lookup = new Map();
    list.forEach(function (node) {
        var key = methods.keyFn(node);
        if (key === null) {
            return;
        }
        if (lookup.has(key)) {
            lookup.get(key).append(node);
        }
        else {
            lookup.set(key, new AdjacencyNode(node));
        }
    });
    // Populate the dependancy array for each adjacency node.
    lookup.forEach(function (value) {
        for (var _i = 0, _a = value.node; _i < _a.length; _i++) {
            var pivotNode = _a[_i];
            for (var _b = 0, _c = methods.depsFn(pivotNode); _b < _c.length; _b++) {
                var depKey = _c[_b];
                if (depKey === null) {
                    return;
                }
                var depRec = lookup.get(depKey);
                if (typeof depRec === "undefined") {
                    depRec = new AdjacencyNode(methods.nullNode(depKey));
                    lookup.set(depKey, depRec);
                }
                // the dependency portion
                value.dep.push(depRec);
            }
            for (var _d = 0, _e = methods.predsFn(pivotNode); _d < _e.length; _d++) {
                var predKey = _e[_d];
                if (predKey === null) {
                    return;
                }
                var predRec = lookup.get(predKey);
                if (typeof predRec === "undefined") {
                    predRec = new AdjacencyNode(methods.nullNode(predKey));
                    lookup.set(predKey, predRec);
                }
                // the predecessor portion
                predRec.dep.push(value);
            }
        }
    });
    var result = [];
    lookup.forEach(function (value) {
        if (typeof value === "undefined") {
            return;
        }
        result.push(value);
    });
    return result;
}
exports.ConstructAdjacencyList = ConstructAdjacencyList;
/**
 * General Topological Sort
 *
 * https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search
 *
 * while there are UNMARKED nodes:
 *   select an UNMARKED node N
 *   VISIT N
 *
 * VISIT N
 *   if N has a TEMPORARY mark then you have a cycle
 *   if N is UNMARKED:
 *      TEMPORARY mark N
 *      for each dependency M of N:
 *         VISIT M
 *      PERMANENT mark N
 *      push N to L
 *
 * @param nodes : list of nodes
 *        The precise sort is, of course, not guaranteed.
 * @returns Array : topological sorted list of T's
 **/
function Toposort(nodes, methods) {
    var al = ConstructAdjacencyList(nodes, methods);
    var result = [];
    var VISIT = function (na) {
        if (na.mark === Mark.TEMPORARY) {
            na.node.forEach(function (node) { methods.cycleFn(node); });
            return;
        }
        if (na.mark === Mark.PERMANENT) {
            return;
        }
        na.mark = Mark.TEMPORARY;
        if (typeof na.dep !== "undefined") {
            na.dep.forEach(function (ma) { VISIT(ma); });
        }
        na.mark = Mark.PERMANENT;
        na.node.forEach(function (node) { result.unshift(node); });
    };
    al.forEach(function (na) { VISIT(na); });
    return result;
}
exports.Toposort = Toposort;
//# sourceMappingURL=toposort.js.map