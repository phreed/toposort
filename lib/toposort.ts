/*
* @author Samuel Neff (https://github.com/samuelneff)
*
* based almost entirely on gist from
*
* @author SHIN Suzuki (shinout310@gmail.com)
*
 * https://gist.github.com/shinout/1232505
*/

/// <reference types="node" />
/// <reference types="core-js" />

export enum Mark {
    UNMARKED = 0,
    TEMPORARY = 1,
    PERMANENT = 2
}
export class AdjacencyNode<T> {
    constructor(node: T) {
        this.node = node;
    }
    mark: Mark;
    node: T;
    dep: AdjacencyNode<T>[];
}
export type AdjacencyList<T> = AdjacencyNode<T>[];

/**
 * The KeyFn returns a key when passed a node.
 * 
 * an example for buildin a key given a number.

function numberKeyFn(node: number): string => {
    return node.toString();
}
 */
export interface KeyFn<T> {
    (node: T): string;
}

/**
 * The DepsFn returns the keys for a set of dependencies for a node.
 * 
 * an example for indexing a list of numbers paired with an array of depencencies.
 *

function numberDepsFn(node: number[]): string[] {
    return node.map(toString);
}
 */
export interface DepsFn<T> {
    (node: T): string[];
}

/**
 * 
 */
export function ConstructAdjacencyList<T>(list: T[], keyFn: KeyFn<T>, depsFn: DepsFn<T>): AdjacencyList<T> {
    // Builds a map based on a key generated by 'keyFn'.
    let lookup = new Map<string, AdjacencyNode<T>>();
    list.forEach((node: T) => {
        lookup.set(keyFn(node), new AdjacencyNode<T>(node));
    })
    // Populate the AdjacencyList.
    lookup.forEach((value) => {
        for (let depkey of depsFn(value.node)) {
            let deprec = lookup.get(depkey);
            if (typeof deprec === "undefined") { continue; }
            // the dependency portion
            deprec.dep.push(value);
        }
    })
    let result: AdjacencyList<T> = [];
    lookup.forEach((value): void => {
        if (typeof value === "undefined") { return; }
        result.push(value);
    });
    return result;
}

/**
 * Used by the topology sort when the input contains cycles.
 */
export interface CycleFn<T> {
    (node: T): void;
}


/**
 * General Topological Sort
 * 
 * https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search
 * 
 * while there are UNMARKED nodes:
 *   select an UNMARKED node N
 *   VISIT N
 * 
 * VISIT N
 *   if N has a TEMPORARY mark then you have a cycle
 *   if N is UNMARKED:
 *      TEMPORARY mark N
 *      for each dependency M of N:
 *         VISIT M
 *      PERMANENT mark N
 *      push N to L
 *
 * @param nodes : list of nodes
 *        The precise sort is, of course, not guaranteed.
 * @returns Array : topological sorted list of T's
 **/
export function Toposort<T>(nodes: T[],
    cycleFn: CycleFn<T>,
    keyExtractionFn: KeyFn<T>,
    dependencyFn: DepsFn<T>): T[] {

    let al = ConstructAdjacencyList<T>(nodes, keyExtractionFn, dependencyFn);
    let result: T[] = [];
    let visit = (na: AdjacencyNode<T>): void => {
        if (na.mark === Mark.TEMPORARY) {
            cycleFn(na.node);
            return;
        }
        if (na.mark === Mark.PERMANENT) { return; }

        na.dep.forEach((ma) => { visit(ma); })
        result.push(na.node);
    }
    al.forEach((na) => { visit(na); });
    return result;
}
